# bug记录

## 1. xhttp_connect导致的terminate问题

### 总体信息

- 时间： 2023.1.17
- 模块： http连接处理
- 版本： V1.0

### 问题描述

处理客户端通信连接完成后，服务器总进程出现terminate

### 问题引入原因

xhttp_connect的do_http__()函数是被服务器异步调用，而xhttp_connect对象是堆栈区对象，当本轮循环结束，对象被回收，导致do_http__()所在线程内资源消失，造成线程不安全。

### 问题解决方式

- 是否解决： 是
- 如何处理：
    开始讲值备份传入线程内容，但造成资源的浪费。然后使用new在动态内存区创建对象，由xhttp_server收集xhttp_connect指针并统一进行管理。

### 总结补充

1. 线程的数据安全非常重要。
2. 线程尽量不要以by reference的方式传值。

## 2. xhttp_connect导致的terminate问题 ②

### 总体信息

- 时间： 2023.1.18
- 模块： http连接处理
- 版本： V1.0

### 问题描述

处理客户端通信连接完成后，服务器总进程出现terminate

### 问题引入原因

连接处理线程没有join，也没有detach。这样会导致在线程析构的时候，直接调用terminate导致程序直接结束。

### 问题解决方式

- 是否解决： 是
- 如何处理：
    加上detach()

### 总结补充

学到了

## 3. uncatched exception问题

### 总体信息

- 时间： 2023.1.20
- 模块： http连接处理
- 版本： V1.0

### 问题描述

在做了异常处理之后，程序还是被xyq::xconnect_exception挂了

### 问题引入原因

在xhttp_connect::do_http__()中开了个新线程，异常是新线程抛出来的，异常处理是主线程做的。

### 问题解决方式

- 是否解决： 是
- 如何处理：
    新线程做异常处理

### 总结补充

学到了

## 4. 超时管理模块中出现的segmentation fault问题

### 总体信息

- 时间： 2022.1.28
- 模块： 超时管理模块
- 版本： V1.1

### 问题描述

【偶现】当连接超时，xhttp_server::manage_http_connect线程需要对超时的线程进行关闭，此时有可能出现segmentation fault导致程序崩溃。*ps: 好恶心的问题，吐了！！！*

### 问题引入原因

【已知】
    1. 经过调试发现问题出现在xhttp_connect::xc_close函数中，这个函数调用了xhttp_server::remove_connect函数。如果不调用就不会出错。
    2. xc_close()是在xhttp_connect调用pthread_cancel之后发生的。
【猜测】
    1. 首先，这个问题并不是必现的，而这里涉及了多线程，所以猜测和线程有关。
    2. 经过查阅资料得知pthread_cancel这个过程是发生在内核的，线程不会立刻停止，而是到下一个检查点才会停止线程，因此，猜测线程没有被充分停止，导致资源被析构了，而还有进程去访问这些失效的资源。

### 问题解决方式

 - 是否解决：未完全解决
 - 如何处理：
     1. 此时主要涉及到xhttp_connect::time_out()函数和xhttp_connect::do_http__()中业务处理逻辑的资源竞争。**对xhttp_connect对象增加了status状态，严格按照status进行线程管理**。RUNNING表示该连接正在进行业务处理逻辑，TIME_OUT表示该连接已经超时。time_out只对RUNNING状态的连接生效，且之后TIME_OUT的连接才会被回收资源。
     2. **xhttp_connect::time_out()在停止线程之后，进行sleep等待线程确实停止再往下运行。但是会导致服务器阻塞，因此使用异步的方式调用time_out。**

### 总结与补充

1. 多线程涉及到资源竞争需要格外关心。
2. 多线程真的恶心，呕！！

# bug记录模板

## 1. 名称

### 总体信息

- 时间：
- 模块：
- 版本：

### 问题描述

这是问题的描述

### 问题引入原因

这是问题引入的原因

### 问题解决方式

- 是否解决：
- 如何处理：

### 总结与补充
